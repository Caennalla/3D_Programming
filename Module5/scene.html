<?doctype HTML>
<html>
<head>
  <meta charset="utf-8">
  <script src="./lib/jquery-1.9.1.min.js"></script>
  <script src="./lib/three.js"></script>
  <script src="./lib/d3.v3.js"></script>
  <script src="scene.js"></script>
  <!-- vertex shader for custom lighting --->
  <script id="light-vs" type="x-shader/x-vertex">
    // light struct
    struct Light {
       vec3 pos;
	   vec4 color;
	   vec3 target;
	   float angle;
	   float distance;
	   float exponent;
	   float decay;
	   float intensity;
    };
	
    // global ambient
    uniform vec4  u_ambient;

    // our directional light 
    uniform Light dirlight;
	
	// our spotlight
	uniform Light spotlight;
    
    varying vec2 v_uv;    
    varying vec4 v_color;
	
	//Ambient light 
	varying vec4 ambientLight;
	//Spotlight
	varying vec3 spotLightPosition;
	varying vec4 spotLightColor;
	varying vec3 spotLightTarget;
	varying float spotLightAngle;
	varying float spotLightDistance;
	varying float spotLightExponent;
	varying float spotLightDecay;
	varying float spotLightIntensity;
	
	//Directional light
	varying vec3 directLightDirection;
	varying vec4 directLightColor; 	
	
	//Normal of this vertex
	varying vec3 outNormal;
	
	//Vertex position in world space
	varying vec3 wcPos;


    void main() {

		v_color = vec4(1);
		
		//Normalize directional light position, we can do it here because the position of light won't change
		directLightDirection = normalize(dirlight.pos);
		directLightColor = dirlight.color;
		
		//Spotlight
		spotLightPosition = spotlight.pos;
		spotLightColor = spotlight.color;
		spotLightTarget = spotlight.target;
		spotLightAngle = spotlight.angle;
		spotLightDistance = spotlight.distance;
		spotLightExponent = spotlight.exponent;
		spotLightDecay = spotlight.decay;
		spotLightIntensity = spotlight.intensity;
		
		//Ambient light
		ambientLight = u_ambient;
		
        // pass texcoords
        v_uv    = uv;
		// Normalize by using world coordinates, modelMatrix means objects matrices in world coordinates
		outNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
		
		//wcPos = normalMatrix * position;
		//wcPos = vec3(modelViewMatrix).xyz * position;
		
		wcPos = vec3(vec3(modelMatrix).xyz * position);
		
        // compute vertex position 
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1);
    
    }

  </script>
  <!-- fragment shader for custom lighting --->
  <script id="light-fs" type="x-shader/x-fragment">
	
    uniform sampler2D map;

    varying vec2 v_uv;
    varying vec4 v_color;
	
	//Ambient light 
	varying vec4 ambientLight;
	
	//Spotlight
	varying vec3 spotLightPosition;
	varying vec4 spotLightColor;
	varying vec3 spotLightTarget;
	varying float spotLightAngle;
	varying float spotLightDistance;
	varying float spotLightExponent;
	varying float spotLightDecay;
	varying float spotLightIntensity;
	
	//Directional light
	varying vec3 directLightDirection;
	varying vec4 directLightColor; 	
	
	//Original normal according to world coordinates
	varying vec3 outNormal;
	
	//Vertex position in world space
	varying vec3 wcPos;

    
    void main(){
		//Variable in which we store the computed color
		vec4 LightAmount;
		//Spotlight variable
		vec4 spotLightColorAmount = vec4(0.0,0.0,0.0,0.0);
		//Spot effect variable
		float spotEffect;
		//Attenuation variable
		float att;
		//Normalized value in this fragment
		vec3 fragmentNormal = normalize(outNormal);	
		//Spotlight direction compared to fragment position
		vec3 DirectionToFragment = vec3(spotLightPosition - wcPos);
		
		float dist = length(DirectionToFragment);
		
		// Calculate the dot product
		float NdotL = max(dot(fragmentNormal, normalize(DirectionToFragment)), 0.0);
		
		//Spotlight direction
		vec3 spotLightDirection = spotLightPosition - spotLightTarget;
		
		if(NdotL > 0.0){
		
			spotEffect = dot(normalize(spotLightDirection), (-DirectionToFragment));
			
			if(spotEffect > spotLightAngle){
				if(dist > 0.0 && dist <= spotLightDistance){
					spotEffect = pow(spotEffect, spotLightExponent);
					att = 1.0 / ((1.0 + 0.0 * dist + (dist * dist * spotLightDecay)));
					spotLightColorAmount = spotLightColor * att;
				}
			}
			
		}
		
		
		//Directional lights intensity
		float intensity = max(dot(fragmentNormal, directLightDirection), 0.0);

		LightAmount = (intensity * directLightColor) + ambientLight + spotLightColorAmount;
		
		
		// combine texel color with received color from vertex shader
		gl_FragColor = texture2D(map, v_uv) * LightAmount;
    }
  </script>
</head>
<body>
<div id="main" width="800" height="600"></div>
<div id="fps" style="position:absolute;width:100px;height:50px;top:10px; left:10px;"></div>
</body>
</html>
